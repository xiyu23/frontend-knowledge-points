## 1、贪心算法

如何证明某个问题可以用贪心算法解决？即如何证明它具有贪心选择性质。

### 1.1、0-1背包问题（动态规划）

无法用贪心算法解。

### 1.2、分数背包问题（贪心）

可以用贪心算法解。

求证：为什么可以用？

证明：

需要证明它具有最优子结构的性质，即问题的最优解一定包含了子问题的最优解。

问题规模为N，对应的解为An。解An中包含了商品Pm（单位价值也记为Pm），质量为Wm，它提供的价值为Vm = Pm\*Wm。如果除去商品Pm，那么就产生了一个子问题：背包大小为W-Wm，在剩余的这些商品中如何产生最大价值。这个子问题的解设为An-1，那么An-1的价值=An的价值-Pm\*Wm。An-1的最优解应该就是An去掉Pm之后的结果，否则一定能找到一个解An-1'它的价值大于An-1。那么问题的解An=An-1' + Pm*Wm > An，这与题干假设矛盾。

故最优解一定也包含子问题的最优解。


### 1.3、在线问题（*On-line Algorithms*）

数据结构与算法，P358。

不知道完整的输入序列，即处理完当前对象后才能处理下一个。

#### 1、*next fit*

如果当前item可以放到上一个bin之中，就放进去；否则新建一个bin放入。

< 2Mbins

#### 2、*first fit*

遍历现有的bin，找到第一个可以容纳下item的bin放入，否则新建一个bin放入。

< 1.7Mbins

时间复杂度：O(N<sup>2</sup>)，但是可以做到O(Nlog<sub>2</sub>N)

#### 3、*best fit*

类似*first fit*，但在寻找放在哪个bin时，选择最紧凑的那个bin。

< 1.7Mbins

### 1.4、离线问题（*Off-line Algorithms*）

数据结构与算法，P362。

与在线问题相反，已经给定了完整的输入序列。

## 2、动态规划（*dynamic programming*）

任何递归的公式都可以直接通过递归算法表达，将递归算法转换成非递归的、并在表中记录子问题的解，这样的方法叫做动态规划。

## 3、分治法（*divide and conquer*）