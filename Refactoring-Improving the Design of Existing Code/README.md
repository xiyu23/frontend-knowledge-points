### 2020-09-01 P54
1. 最好不要在另一个对象的属性基础上运用`switch`语句。如果不得不这么做，也应该在对象自己的数据上使用，而不是在别人的数据上使用。即，移动这部分代码到所依赖数据的所属对象中去。

2. 重构是改善代码结构，让以后的维护更加容易。而性能优化不是重构，它可能为了达到性能而写得非常难以读懂。

3. 重构时可能将原本只需要计算一次的方案，改成了计算多次。这势必会影响性能，但是除非你评估过它已经达到了影响系统性能的地步，否则请不要拒绝这样的重构。因为你现在戴的帽子是`重构`，当重构完成后你再尝试戴上`性能优化`的帽子，这时你会站在一个比先前更好的位置上来完成性能优化。

### 2020-09-02 P66
4. 你的代码有两个读者：一个是计算机，另一个是未来其它开发者。而后者更加重要，却容易被我们所忽视。而且，未来的那个人，有时候就是自己。因此，请努力将代码变得**易读**。

5. 尽量不要发布接口，在修改这个已发布接口(published interface)时，*让旧接口调用新接口*。

6. 未完成的重构工作就是"技术债务"。很多项目都需要**借债**来保证更有效地运转，但是借债就要付息，利息就是维护和修改时因未重构而增加的额外成本。利息太高就会被压垮，故应当随时重构来偿还一部分债务。

7. 如果项目已接近尾声而没有时间重构，那么说明其实你早该重构。

### 2020-09-02 P78
8. 编码前的设计不应该考虑过于灵活，过多的灵活性导致系统复杂度上升。而且当最后发现这些灵活性其实并无用处之时，这才是最大的失败。

9. 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。**十有八九你是错的**。

10. 大多数程序把大半的时间都花费在了*一小半*代码身上。

11. 积极地分解函数，为函数取一个**干什么**的名字，而不要是**怎么做**的名字。

### 2020-09-13 P82

12. 如果很多函数的参数列表总有那么几个是相同的，那么应当将这些参数放到一个对象中，用对象代替长参数列表。

```
foo(person, movie, days, p1, p2);
bar(person, movie, days, p1, p2, p3, p4);
```

```
class Unnamed {
  person;
  movie;
  days;
}

foo(unnamed, p1, p2);
bar(unnamed, p1, p2, p3, p4);
```

13. 代码应该很容易被修改，如果为达成某个目的而修改了好几个地方，那么就该考虑是否应当将这几个地方整合，当下次修改时只需要修改一处。[Divergent Change, 发散式变化]()**就是指面对每次不同的需求变化，总是有个类被改来改去。**

**针对某一外界变化的所有相应修改，都只应该发生在单一类中**

14. 和`13`类似，[Shotgun Surgery](散弹式修改)是指**面对变化，需要四处修改。**即每遇到某种变化，都必须在许多不同的类中做修改，遍布四处的代码很容易被遗忘。这时就应当**把所有需要修改的代码放进同一个类**。

**原则：**

面对外界变化的修改，都应该集中在一处。



