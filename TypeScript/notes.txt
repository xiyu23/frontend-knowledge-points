1. TypeScript(微软推出)是javascript的超集，相当于是js的语法糖，好处就是js类型松散，而ts可以是强类型利于编译时静态检查避免出错，另外面向对象方面ts具备面向对象语言的几乎全部特性写起来规范。但.ts需要编译成.js才能运行。

2. 安装TypeScript
$ npm install -g typescript

- 更新typescript

    $ npm update -g typescript

tsc的版本过低(1.0.3)，但是安装的ts却高很多？
检查一下是不是vs安装了ts1.0版本导致，可以去看下PATH，把vs的删掉，以让npm安装的优先级更高。（或许需要重启电脑生效）

3. 编译.ts为.js
$ tsc hello.ts

3. 2种类型如果其内部结构兼容，则这两种类型就可称之为兼容的
In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit implements clause.

interface Person {
  firstName: string;
  lastName: string;
}

// 1 - 兼容
let user = {
  firstName: "Yu",
  lastName: "Hui",
  another: "Xi"
};

// 2 - 不兼容，编译时报错，因为缺少Person定义lastName丢失
let user = {
  firstName: "Yu",
  another: "Xi"
};

4. class的构造函数参数列表中，参数前增加public表示使该参数也成为类成员变量
As of note, the use of public on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.

5. what is 'gulp'
gulp(/ɡʌlp/, 大口吞咽饮料或食物，often audibly(/ˈɔːdəbli/))
整天手工、重复且耗时的工作，让这个workflow变得自动又高效的小工具。
gulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something.

  1. 安装gulp
  $ npm install gulp-cli -g (-g表示全局安装)

  2. 写入dependencies
  把gulp写入devDependencies(开发环境)，因为只是开发过程中依赖它，用于打包整理等，生产环境并不需要它
  $ npm install gulp -D 
  或 
  $ npm i gulp -D (i是install的简写)
  或
  $ npm install gulp --save-dev (-D是--save-dev的缩写)

  把gulp写入dependencies(生产环境)，只是个例子对比，不要这么做。
  $ npm install gulp -S
  或
  $ npm install gulp --save (-S是--save的缩写)

  3. 安装npx并新建一个gulpfile.js文件
  $ npx -p touch nodetouch gulpfile.js

  4. gulp-typescript
  是一个管理ts编译工作流的gulp插件，插件通过ts的API，把ts编译选项暴露给gulp使用。
  A gulp plugin for handling TypeScript compilation workflow. The plugin exposes TypeScript's compiler options to gulp using TypeScript API.
  如ts.createProject('your-tsconfig.json-file')

  5. src()
  创建一个用于从文件系统读取Vinyl objects的stream
  Vinyl: 描述文件信息的对象，最主要包含path、content属性。
  src(['hello.js', 'hi.js', ...]); // 读这些源文件

  6. dest()
  创建一个用于将Vinyl objects写入文件系统的stream
  dest('dist') // 将输出写到dist目录下


6. tsconfig.json
  6.1 noImplicitAny: true
  如果表达式/声明中有隐式的Any类型，则警告。Raise error on expressions and declarations with an implied any type
  6.2 onEmitOnError: true
  如果tsc编译有错，则不要生成output。Do not emit outputs if any errors were reported.
  6.3 compileOnSave: true
  保存时自动编译ts。makes it easy to update your code in a running web app.

7. Browserify
把我们所有模块打包成一个js文件，放到浏览器中运行。This is exactly what Browserify does.
  7.1 安装
  $ npm i -D browserify tsify vinyl-source-stream
  tsify和gulp-typescript类似，都是提供访问ts compiler选项的插件
  vinyl-source-stream是一个能将browserify输出的结果逆向回gulp能理解的格式（有点像reverse-source-map?）

  7.2 debug
  browserify有个属性debug开关，打开的话，生成的bundle.js中包含了source map信息，这样可以在浏览器里调试到源代码的具体位置（即在打包之前的源代码中放置一个断点，刷新页面后会跳到源代码的位置便于调试）。
  bundle.js中含有类似于:
  sourceMappingURL=xxxx

  7.3 browserify构造函数
  basedir - 描述browserify开始打包的目录。is the directory that browserify starts bundling from for filenames that start with .
  entries - 指明入口文件，和形参第一个参数files一致，可以是string/file object/array of thoes types

8. Watchify, Babel, Uglify
  8.1 Watchify
  运行过gulp后，它并不结束，而是继续保持运行状态，这样一旦保存文件，就会刷新。省的手动运行gulp了。

  8.2 Babel
  把ES6+的转换为ES5和ES3。

  8.3 Uglify
  压缩打包后的代码：get minified into an unreadable mess!