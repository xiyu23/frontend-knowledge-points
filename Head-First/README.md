## 1.装饰者模式
> 1. "动态地将行为附加到对象之上"，是指可以不断地用*装饰者*来包装一个*被装饰者*
> 2. 包装后得到的对象，客户端无法判断究竟最里面、最初的那个*被装饰者*到底是谁

书中提到，装饰者模式是指用*装饰者*将*被装饰者*包裹(wrap)起来。

装饰过后的对象，还可以**继续**用*装饰者*进行进一步的装饰(wrap)。

假设我们有一个对象需要装饰（称之为被装饰者），当装饰完成之后所得的新对象还需要可以被装饰，那就意味着：

**被装饰者和装饰者必须具有相同的类型<sup>1</sup>**。

> 1.相同的类型：如果它们拥有共同的父类，也可以满足要求。

首先尝试下完全相同的类型。

比如*装饰者*包含了一个指向*被装饰者*的指针`p`，这个`p`指向的对象类型**既是装饰者，又是被装饰者**。

![最初的想法](/Head-First/imgs/decorator-a.png)

这样有个坏处，被装饰者和装饰者混在一起了。而且也不能说**Coffee既是被装饰者又是装饰者**，因为**Coffee只能是被装饰者，Suger只能是装饰者**，要把它们区分开来。

那就考虑下被装饰者和装饰者拥有共同的父类。

![共同父类想法](/Head-First/imgs/decorator-b.png)

这样就可以写如下代码：

```C++
// 被装饰者：Coffee
// 装饰者：Mocha
Coffee coffee = new Coffee(); // 先有一个被装饰者
Mocha wrappedByMocha = new Mocha(coffee); // 放进装饰者里，被Mocha装饰
```

`wrappedByMocha`就是`coffee`被`mocha`装饰后的结果，它是一个*装饰者*，但由于继承了`Component`，所以**也可以继续被装饰**。

但是！为什么书上的UML图是这样的（为什么要在父类和装饰者之间加一个抽象的装饰者类*Abstract 装饰者*呢？）：

![书上标准的类图](/Head-First/imgs/decorator-c.png)

祭出一句经典原则：

> 针对接口编程，而不是具体实现

怎么理解呢？

如果我们的装饰者子类直接从`Component`继承，因为这里`Component`只是提供一个类似于'共同基类'的方便（让装饰后的对象(装饰者)还可以被装饰者装饰），而且`Component`作为了*组件*(就是说我们所要装饰的对象，如被装饰者`Coffee`)父类，所以我们并不能直接在`Component`去做一些和装饰者相关的事情。

没有抽象装饰者作为中间层，那么我们**需要为每个装饰者子类实现很多重复的逻辑**<sup>1</sup>。

> 1.可以参考`Decorator-Pattern`和`Decorator-Size-Pattern`，那里有详细解释。

主要因为装饰者具体类它们有很多共性，所以可以去**针对接口编程**。

## 一些原则
1. 在对象的方法内，我们应该只调用属于以下范围的方法：
  - 该对象本身
  - 被当做方法的参数而传递进来的对象
  - 此方法所创建或实例化的任何对象
  - 对象的任何`组件`<sup>1</sup>(1是指此对象所持有的成员变量)